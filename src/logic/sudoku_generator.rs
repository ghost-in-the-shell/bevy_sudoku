use bevy::prelude::*;
use bevy::utils::HashMap;
use sudoku::Sudoku;

use crate::logic::board::{Coordinates, Value};

pub struct GeneratorPlugin;

impl Plugin for GeneratorPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<PuzzleState>()
            .add_event::<NewPuzzle>()
            .add_systems(Startup, first_sudoku)
            .add_systems(Update, generate_sudoku);
    }
}

#[derive(Event)]
pub struct NewPuzzle;

#[derive(Default, Resource)]
struct PuzzleState {
    completed: HashMap<Coordinates, Value>,
    initial: HashMap<Coordinates, Value>,
}

/// Converts a sudoku generated by the `sudoku` crate into a usable format
fn parse_sudoku(sudoku: Sudoku) -> HashMap<Coordinates, Value> {
    let (mut row, mut column) = (1, 0);
    let mut map = HashMap::default();

    // Sudoku::iter() goes from left to right, top to bottom
    for value in sudoku.iter() {
        column += 1;
        if column == 10 {
            row += 1;
            column = 1;
        }
        let square = Coordinates::compute_square(row, column);

        let coordinates = Coordinates {
            row,
            column,
            square,
        };

        let value = match value {
            Some(v) => Value::Filled(v),
            None => Value::Empty,
        };
        map.insert(coordinates, value);
    }
    map
}

/// Sends an event to create a new sudoku on app startup
fn first_sudoku(mut event_writer: EventWriter<NewPuzzle>) {
    event_writer.send(NewPuzzle);
}

/// Create a new sudoku puzzle from sudoku crate
fn generate_sudoku(
    mut new_puzzle_events: EventReader<NewPuzzle>,
    mut puzzle_state: ResMut<PuzzleState>,
) {
    for _ in new_puzzle_events.read() {
        let completed = Sudoku::generate_filled();
        let initial = Sudoku::generate_unique_from(completed);
        puzzle_state.initial = parse_sudoku(initial);
        puzzle_state.completed = parse_sudoku(completed);
    }
}
